from easydict import EasyDict


ROOT_DIR = __file__.rsplit("/", 3)[0]

# Directory to save the all outputs generated by various tools
OUTPUT_DIR = f"{ROOT_DIR}/outputs"

# Define agent status for frontend display
AGENT_STATUS = {
    "GENERATING": 0,    # The agent is generating contents
    "TOOL_CALLING": 1,  # The agent is calling a tool
    "TOOL_RUNNING": 2,  # The agent is calling a tool
    "IDLE": 3,  # The agent is idle
    "FINAL_RESPONSE": 4,  # The agent is generating the final response
    "TOOLCHAIN": 5, # The agent is summarizing the toolchain
    "SKIP": 6,  # Not to display the response to the user
    "TITLE": 7,  # The agent is generating the title of the conversation
    "ERROR": 8,  # The agent is in error state
    "WORKFLOW": 9,  # The agent is generating the workflow
    "WORKFLOW_ERROR": 10,  # The agent is in workflow error state
}
AGENT_STATUS = EasyDict(AGENT_STATUS)


TOOLNODE_STATUS ={
    "INIT": "INIT",  # The tool node is initialized but not yet validated
    "CONNECTED": "CONNECTED",  # The tool node is connected and ready to be executed
    "EXECUTED": "EXECUTED",  # The tool node has been executed
}

TOOLNODE_STATUS = EasyDict(TOOLNODE_STATUS)

# Detailed descriptions of all tool arguments to be taken as input. These are protein entities that are necessary to decide on whether a tool could be added to the agent's tool using workflow. Only when these arguments are all provided can the agent have the possibility to use the tool. These are protein entity level restrictions. The selection should also consider the tool's own requirements.
INPUT_FLOW_ARG_DESCRIPTION = {
    "CLUSTALW_ALN_PATH": "Path to the input multiple sequence alignment file. HMMER can autodetect the format, but Stockholm is the preferred and most feature-rich format. Corresponds to the <msafile> positional argument.",
    "HMMER_HMM_PATH": "Path to the input profile HMM file. This model is used as a query to search against the sequence database. Corresponds to the <hmmfile> positional argument.",
    "HHSUITE_HMM_PATH": "The path to the .hmm file. A Hidden Markov Model (HMM) file generated from the input MSA, ready for use in HH-suite tools such as HHsearch",
    "HHSUITE_A3M_PATH": "The path to the .a3m file. A multiple sequence alignment (MSA) file of homologous sequences identified during the search, typically generated by HHblits, which is able to build a HMM.",
    "FASTA_PATH": "The path to the .fasta file. A FASTA format file containing the protein sequence.",
    "AA_SEQUENCE": "The amino acid sequence of the protein. It should be a string of characters representing the amino acids. Example: 'ACDEFGHIKLMNPQRSTVWY'.",
    "STRUCTURE_PATH": "The path to the .pdb or .cif file. A file containing the 3D structure of the protein.",
    "FOLDSEEK_SEQUENCE": "The foldseek sequence. It is a string of the protein structure tokens generated by the foldseek tool.",
    "TEXT": "Meaningful keywords or functional descriptions that could be used for searching proteins/literatures/wiki and even text-based protein design",
    "SMILES": "A SMILES(simplified molecular input line entry system) string representing the sequence of the ligand.",
    "PDB_ID": "The PDB ID of the protein. It is a unique identifier for the protein structure in the Protein Data Bank.",
    "HMM_PATH": "The path to the .hmm file. A Hidden Markov Model (HMM) file generated from the input MSA, ready for use in HHsearch or other tools.",
    "UNIPROT_ID": "The UniProt ID of the protein. It is a unique identifier for the protein in the UniProt database.",
    "PFAM_ID": "The Pfam ID of the protein. It is a unique identifier for the protein family in the Pfam database.",
    "INTERPRO_ID": "The most frequently occurring signature accession in interproscan results. This provides insight into the most common functional annotations found across the input sequences.",
    "INTERPRO_NAME": "The name of the most frequently occurring signature accession in interproscan results. This provides a human-readable label for the most common functional annotation found across the input sequences.",
    "UNIPROT_KEYWORD": "The keyword to be searched in the UniProt database. It is usually a short term or phrase that describes the protein's function or properties. e.g. 'enzyme', 'receptor', 'kinase', etc.",
    "ADAPTOR_DIRECTORY": "The directory of the finetuned saprot model. Only for specifying a finetuned saprot downstream task model.",
    "TRAINING_DATASET": "Training dataset of saprot downstream model. Dataset should be a .csv file with three required columns: sequence, label and stage",
    "CHAIN_ID": "The chain ID of the protein structure.",
}

# Detailed descriptions of all tool arguments to be taken as output. These are protein entities that are necessary to decide on whether a tool could be added to the agent's tool using workflow. These denotes crucial information that the tool will return to the agent. These are protein entity level restrictions. The selection should also consider the tool's own requirements.
OUTPUT_FLOW_ARG_DESCRIPTION = {
    "HHR_PATH": "The path to the output file in HH-suite result format (.hhr), summarizing the pairwise alignment, scores, and sequence identities.",
    "FASTA_PATH": "The path to the .fasta file. A FASTA format file containing the protein sequence.",
    "AA_SEQUENCE": "The amino acid sequence of the protein. It should be a string of characters representing the amino acids. Example: 'ACDEFGHIKLMNPQRSTVWY'.",
    "STRUCTURE_PATH": "The path to the .pdb or .cif file. A file containing the 3D structure of the protein.",
    "FOLDSEEK_SEQUENCE": "The foldseek sequence. It is a string of the protein structure tokens generated by the foldseek tool.",
    "TEXT": "Meaningful keywords or functional descriptions that could be used for searching proteins/literatures/wiki and even text-based protein design",
    "PDB_ID": "The PDB ID of the protein. It is a unique identifier for the protein structure in the Protein Data Bank.",
    "UNIPROT_ID": "The UniProt ID of the protein. It is a unique identifier for the protein in the UniProt database.",
    "PFAM_ID": "The Pfam ID of the protein. It is a unique identifier for the protein family in the Pfam database.",
    "SEQUENCE_RECORD_LIST": "A list of sequence records. Each record is a dictionary containing the 'id', 'description', and 'sequence' for one entry from the FASTA file.",
    "PFAM_NAME": "The name of the Pfam entry. This is a human-readable label for the Pfam family that the protein belongs to.",
    "PFAM_TYPE": "The type of the Pfam entry, such as 'domain', 'family', etc.",
    "INTERPRO_ID": "The most frequently occurring signature accession in interproscan results. This provides insight into the most common functional annotations found across the input sequences.",
    "INTERPRO_NAME": "The name of the most frequently occurring signature accession in interproscan results. This provides a human-readable label for the most common functional annotation found across the input sequences.",
    "HMMER_HMM_PATH": "Path to the output profile HMM file. This is the primary output of hmmbuild and is required for tools like hmmsearch. Corresponds to the <hmmfile> positional argument.",
}


# Don't consider these arguments as required output unless the user clearly asks for them or their related tools.
TOOL_SPECIFIC_ARG_DESCRIPTION = {
    "PINAL_CSV_PATH": "The detailed results from Pinal.",
    "MPNN_CSV_PATH": "The detailed results from ProteinMPNN",
    "CLUSTALW_ALN_PATH": "The resulting multiple sequence alignment of the provided protein sequences.",
    "DIFFAB_RESULT_DIR": "The directory containing the optimized antibody structures saved as PDB files.",
    "HHSUITE_A3M_PATH": "A multiple sequence alignment (MSA) file of homologous sequences identified during the search.",
    "INTERPROSCAN_TSV_PATH": "The primary, structured output of the InterProScan analysis in a tab-separated values (TSV) format. Each row represents a found match, detailing the analysis method, signature accession, start/stop locations, and score. It includes annotations for protein families, domains, and functional sites. Optional columns for GO terms and pathway annotations will be present if those analyses were enabled.",
    "INTERPROSCAN_RESULT_DIR": "The main output directory containing all files generated during the InterProScan run. This includes the primary `parsed_tsv` result file, raw InterProScan outputs in other formats (if generated)",
    "MUTATION_SCORE_DICT": "The predicted mutational effect scores of the specific mutant or position. This is a list of scores, each score corresponds to a specific mutation.",
    "MUTATION_SCORE": "The predicted mutational effect score of the specific mutant.",
    "TMSCORE": "The TM-score value representing the structural similarity between the aligned proteins.",
    "CLASSIFICATION_RESULT": "The output of the finetuned saprot model",
    "REGRESSION_RESULT": "The output of the finetuned saprot model",
    "TOKEN_CLASSIFICATION_RESULT": "The output of the finetuned saprot model",
    "HMM_PATH": "The path to the .hmm file. A Hidden Markov Model (HMM) file generated from the input MSA, ready for use in HHsearch or other tools.",
    "ADAPTOR_DIRECTORY": "The directory of the finetuned saprot model. Only for specifying a finetuned saprot downstream task model",
    "HHSUITE_HIT_ID":"""\
        The identifier of the top-ranking hit from the database searched by HH-suite. This is typically a
        PDB ID and chain (e.g., '4A6L_A') when searching structural databases, or a
        family accession (e.g., 'PF00001') for family databases. It is the primary
        key for retrieving the template's structural data."
        """,
    "BLAST_XML_PATH": "The path to the BLAST XML output file containing the results of the BLAST search. This file includes detailed information about each hit, such as sequence identifiers, alignment scores, and E-values.",
    "HMMER_TBLOUT_PATH": "Path to the per-sequence tabular output file. This is a simple, space-delimited, and easily parsable format summarizing the top-scoring domain hit for each query sequence. Generated via the --tblout option.",
    "HMMER_DOMTBLOUT_PATH": "Path to the per-domain tabular output file. This file lists all significant domain hits found in the query sequences, one hit per line, making it ideal for detailed analysis. Generated via the --domtblout option.",
    "UNIPROT_JSON_PATH": "The path to the JSON file containing the results of the Uniprot query.",
    "FOLDSEEK_TSV_PATH": "The path to the TSV file containing all foldseek search results with detailed alignment information.",
}

# These arguments are detailed and tool-related. For input arguments, these are configurations that describe the detail of the tool call. For output arguments, these are detailed information that the tool will return to the agent. These arguments are not protein entity level restrictions, but rather tool-related configurations.
CONFIGURATIVE_ARG_DESCRIPTION = {
    "AA_POSITION": "The amino acid position in the protein sequence. It should be an integer representing the position of the amino acid in the sequence starting from 0.",
    "RFDIFFUSION_CONTIGS": '''\
    Input configuration of the tool RFDiffusion. Mainly composed of numbers and single letters. This is a short notation that defines continuous chains to design. Use a : to define multiple contigs and a / to define multiple segments within a contig. If no specific configuration of the design is provided, leave it as ''. For example:
    contigs='100' - design monomer of length 100;
    contigs='50:100' - design hetero-oligomer of lengths 50 and 100;
    contigs='A:50' - design a binder of length 50 to chain A of defined PDB;
    contigs='E6-155:70-100' - design a binder of length 70 to 100 (sampled randomly) to chain E;
    contigs='A3-30/36/A33-68' - design a loop of length 36 between two segments of defined PDB ranges;
    contigs='' - design all coordinates;
    contigs='A1-10' - keep first 10 positions fixed, design the rest;
    contigs='A' - fix chain A, design the rest;
    contigs='50-100' use dash to specify a range of lengths to sample from.''',
    "MUTATION_INFO": "The mutation information in the format of \"A123B\", where A is the original amino acid, 123 is the position and B is the mutated amino acid. If multiple mutations are provided, they should be separated by colon, e.g. \"A123B:C124D\".",
    "LABEL_NUM": "The number of labels in the described classification task. It is usually an integer representing the number of classes in the classification task. e.g. 2 for binary classification, 10 for 10-class classification.",
    "PROTEIN_LENGTH": "The length of the protein sequence.",
    "CHAIN_ID": "The chain ID of the protein structure.",
    "CHAIN_COUNT": "The total chain count in the PDB file.",
}



# Define agent response format
class AgentResponse:
    """
    Official response format of the agent.
    """
    def __init__(self,
                 content: str,
                 status: int,
                 fragments: list = None,
                 tool_arg: dict = None,
                 error: str = None,
                 workflow: str = None,
                 ):
        """
        Args:
            content: LLM generated content.
            
            status: The status of the agent.
            
            fragments: The fragments of the content. Used for flexible content display.
            
            tool_arg: The dictionary containing the tool arguments.
                - name: The name of the tool.
                - args: The arguments of the tool.
        """
        self.content = content
        self.status = status
        self.fragments = fragments
        self.tool_arg = tool_arg
        self.error = error
        self.workflow = workflow
    
    def to_dict(self):
        d = {
            "content": self.content,
            "status": self.status,
            "fragments": self.fragments,
            "tool_arg": self.tool_arg,
            "error": self.error,
            "workflow": self.workflow,
        }
        return EasyDict(d)


# For test purpose
if __name__ == '__main__':
    print(ROOT_DIR)
    print(OUTPUT_DIR)
    pass
