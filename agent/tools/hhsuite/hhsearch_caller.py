import sys

ROOT_DIR = __file__.rsplit("/", 4)[0]
if ROOT_DIR not in sys.path:
    sys.path.append(ROOT_DIR)
    
import os
import datetime
import torch

from agent.tools.base_tool import BaseTool
from agent.tools.register import register_tool


torch.backends.cuda.matmul.allow_tf32 = True
BASE_DIR = os.path.dirname(__file__)


@register_tool
class HHSearch(BaseTool):
    def __init__(self, out_dir: str = f"{ROOT_DIR}/outputs/hhsearch", **kwargs):
        super().__init__(
            config_path=f"{BASE_DIR}/config.yaml",
            out_dir=out_dir,
            **kwargs
        )
        tool_name = "hhsearch"
        for doc in self.config["document"]:
            if doc["tool_name"] == tool_name:
                self.config["document"] = doc
                break
        self.config["example_output"] = self.config["example_output"][tool_name]
        self.tool_name = tool_name
    
    def __call__(self, query_hmm, database: str = 'uniclust30', evalue: float = 0.001, cpu: int = 10) -> dict:
        query_hmm = f"{self.out_dir}/{query_hmm}"
        start = datetime.datetime.now()
        now = start.strftime("%Y%m%d_%H%M")
        save_dir = f"{self.out_dir}/hhsearch/{now}"
        if not os.path.exists(save_dir):
            os.makedirs(save_dir)
        
        a3m_save_path = f"{save_dir}/{os.path.basename(query_hmm).split('.')[0]}_top-hit.a3m"
        hhr_save_path = f"{save_dir}/{os.path.basename(query_hmm).split('.')[0]}_align-detail.hhr"

        if query_hmm is None:
            print("Usage: HHsearch.sh -query_hmm <QUERY_HMM> [OPTIONS]")
            print("Required parameters:")
            print("  -query_hmm: The query HMM file (generated by HHmake or HHblits).")
            return {"error": "HHsearch encountered an error. Please check your inputs and options."}
        
        # dataset
        db_path_prefix = self._get_database_path(database)

        
        # Call the hhsearch
        cmd =  (f"{ROOT_DIR}/{self.config.HHsearch} -i '{query_hmm}' -d '{db_path_prefix}' "
               f"-o {hhr_save_path} -oa3m {a3m_save_path} -e {evalue} -cpu {cpu} "
               f"> /dev/null 2> {self.log_path}")
        
        
        try:
            os.system(cmd)  
            if os.path.exists(hhr_save_path):
                scores = self._parse_hhr_output(hhr_save_path)
                spend_time = (datetime.datetime.now() - start).total_seconds()
                results = {"top_msa": a3m_save_path, "report": hhr_save_path[len(self.out_dir)+1:], "duration": spend_time}
                results.update(scores)
                return results
            else:
                return {"error": "HHsearch encountered an error. Please check your inputs and options."}
        
        except Exception as e:
            return {"error": str(e)}
        
    def _parse_hhr_output(self, hhr_path: str) -> dict:
        """
        Parses the .hhr output file to extract the top hit's ID and key scores,
        plus the total number of hits. This function is designed to be robust
        against empty or malformed files.
        """
        # This ensures it's always present in the return value, even if no hits are found.
        scores = {
            "msa_length": 0,
            "top_hit_id": None,
            "top_hit_probability": None,
            "top_hit_evalue": None,
            "top_hit_score": None,
        }
        try:
            with open(hhr_path, "r") as f:
                lines = f.readlines()

            # Find the start of the summary table to count hits
            summary_started = False
            hit_lines = []
            for line in lines:
                # The summary table starts after the "No Hit" header line
                if line.strip().startswith("No Hit"):
                    summary_started = True
                    continue
                if summary_started:
                    # The summary ends with a blank line or the start of alignments ('>')
                    if line.strip() == "" or line.startswith(">"):
                        break
                    hit_lines.append(line)
            
            scores["num_hits"] = len(hit_lines)

            # If hits were found, parse the top one from both the summary and detailed sections
            if scores["num_hits"] > 0:
                top_hit_summary = hit_lines[0].split()
            
                top_hit_id = top_hit_summary[1]
                scores["top_hit_id"] = top_hit_id

                # --- KEY CHANGE ENDS HERE ---

                # 1. Parse the summary line for Prob, E-value, and Score
                scores["top_hit_probability"] = float(top_hit_summary[2])
                scores["top_hit_evalue"] = float(top_hit_summary[3])
                scores["top_hit_score"] = float(top_hit_summary[4])
            else:
                scores["error"] = "No hits found in this search."

        except (IOError, ValueError, IndexError) as e:
            # This ensures the tool doesn't crash if parsing fails
            # The print statement is good for debugging.
            print(f"Warning: Could not fully parse HHR file '{os.path.basename(hhr_path)}'. Error: {e}")
        
        return scores

    def _get_database_path(self, database: str) -> str:
        """
        Constructs the full path to the database file based on the provided database name.
        This is useful for ensuring the correct path is used in commands.
        """
        if database == "uniclust30":
            return os.path.join(ROOT_DIR, self.config["UNICLUST"])
        else:
            raise ValueError(f"Unsupported database: {database}.")


if __name__ == '__main__':
    # Test
    hhsearch = HHSearch(BASE_DIR)
    
    input_args = {
        "query_hmm": f"example/example.hmm",
        "evalue": 1e-3
    }
    for obs in hhsearch.mp_run(**input_args):
        os.system("clear")
        print(obs)
    
