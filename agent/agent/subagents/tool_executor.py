import json

from typing import List, Dict

import streamingjson
from agent.utils.constants import AGENT_STATUS, AgentResponse
from agent.tools.tool_manager import ToolManager
from agent.agent.subagents.base_agent import BaseAPI



SYSTEM_PROMPT = """
You are a helpful tool executor. Your task is to extract arguments based on the context information to call a tool.

The plan is here:
PUT_PLAN_HERE

Following the plan, your current step is:
PUT_STEP_HERE

The description of the tool that you have to call is:
PUT_TOOL_DESCRIPTION_HERE

Previous chat history is here:
===
PUT_PREVIOUS_RESPONSE_HERE
===

When you extract the arguments, you must obey these rules:

1. Pre-extraction Sanity Check: Before extracting any arguments, cross-reference the plan, current step, and original user query. Perform these checks to ensure contextual correctness:
    a. Data Type Check: Verify the tool argument (e.g., a structure file) matches the data type the user intends to use.
    b. Entity Check: If multiple proteins exist, confirm this step targets the correct one.
    c. Semantic Specificity Check: Distinguish between nuanced concepts (e.g., "backbone structure" vs. "all-atom structure," or "domain sequence" vs. "full sequence").
    Your final tool_arg must be consistent with these checks.
2. Required Argument Identification: Identify and list all required arguments as specified in the tool's description. You must ensure the argument names are spelled EXACTLY as they appear in the documentation.
3. Argument Availability Verification: Verify that values for all required arguments are present in the provided context (user query, chat history, etc.). If any are missing, you must raise an error.
4. Literal Argument Extraction: For parameters representing concrete data like PATH, FILE_NAME, or AA_SEQUENCE, extract their values directly and literally from the context.
5. Inferred Argument Generation: For parameters that require synthesis, such as TEXT, SUMMARY, or QUESTION, analyze the entire conversation history and the tool's purpose to generate the most appropriate argument.
6. Selection Parameter Handling: For parameters that offer a fixed set of CHOICES, you must select one of the provided options. The selected value must match the spelling in the documentation EXACTLY.
7. Optional Argument Handling: Include optional parameters in the tool_arg dictionary only if their values are explicitly provided or clearly implied in the context. Otherwise, omit them entirely.
8. Handling No-Argument Tools: If the tool to be called requires no arguments, generate an empty JSON object {} for the tool_arg field.
9. Failure Analysis and Correction: If a previous attempt to execute this tool resulted in an error, first analyze the error message and the context. Then, modify the arguments in your new attempt to correct the mistake.


You should extract the arguments in the following format: First generate a "<ToolExecutor>" tag, then extract the
arguments in JSON format, and finally generate a "</ToolExecutor>" tag.

If all required arguments are provided in the context, extract the arguments and generate the action structure as follows:
<ToolExecutor>
{
    "sender": "tool_executor",
    "content": {
        "current_step": "current step of the plan",
        "tool_name": "name of the tool",
        "analysis": "analysis of previous chat history to determine the arguments",
        "tool_arg": {
            "arg_1": "value_1",
            "arg_2": "value_2"
            }
    }
}
</ToolExecutor>

Or if there are any missing required arguments, refuse to extract the arguments and raise an error:
<ToolExecutor>
{
    "sender": "tool_executor",
    "content": {
        "current_step": "current step of the plan",
        "tool_name": "name of the tool",
        "analysis": "analysis of previous chat history to refuse to extract the arguments",
        "error": "xxx"
    }
}
</ToolExecutor>

Now, let's start extracting the arguments.
"""


class ToolExecutor(BaseAPI):
    """
    A sub-agent that selects a tool for the user's request.
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        
    def change_tool_call(self, tool_name: str, tool_arg: dict):
        """
        Change the tool call
        Args:
            tool_name: Changed tool name
            tool_arg: Changed tool arguments
        """
        self.tool_name = tool_name
        self.tool_arg = tool_arg

    def stream_chat(self, plan: dict, step_id: str, message_pool: List[Dict]):
        """
        Stream chat with the user
        Args:
            plan: The plan dictionary.
            step_id: Current task ID.
            message_pool: The pool of messages generated by other agents.
        """
        try:
            ###########################################################
            # First extract the tool name and arguments from the plan #
            ###########################################################
            tool_name = plan[step_id]["tool"]
            
            if tool_name == "chat":
                return_dict = {
                    "sender": "tool_executor",
                    "content": {
                        "current_step": step_id,
                        "tool_name": tool_name,
                        "analysis": "The tool is chat, no arguments are required.",
                        "tool_arg": {},
                        "status": "success"
                    }
                }
                yield AgentResponse(
                    content=json.dumps(return_dict, indent=4),
                    status=AGENT_STATUS.GENERATING,
                )
            
            else:
                tool_description = self.tool_manager.generate_document([tool_name])
                plan_description = json.dumps(plan, indent=4)
                # tool_description = self.tool_manager.generate_argument_document(tool_name)

                # Get previous plan description
                chat_history = "\n".join([json.dumps(msg_dict, indent=4) for msg_dict in message_pool])

                # Generate system prompt
                system_prompt = SYSTEM_PROMPT.replace('PUT_PLAN_HERE', plan_description)
                system_prompt = system_prompt.replace('PUT_STEP_HERE', step_id)
                system_prompt = system_prompt.replace('PUT_TOOL_DESCRIPTION_HERE', tool_description)
                system_prompt = system_prompt.replace('PUT_PREVIOUS_RESPONSE_HERE', chat_history)

                input_messages = [{"role": "user", "content": system_prompt}]
                response = self.client.call_openai(
                    messages=input_messages,
                    stream=True,
                    temperature=0.001,
                )

                complete = ""
                lexer = streamingjson.Lexer()
                for chunk in response:
                    content = "" if chunk.choices[0].delta is None else chunk.choices[0].delta.content or ""
                    lexer.append_string(content)
                    complete += content
                    yield AgentResponse(
                        content=lexer.complete_json().split("<ToolExecutor>")[-1],
                        status=AGENT_STATUS.GENERATING
                    )

                arg_dict_str = complete.split("<ToolExecutor>")[1].split("</ToolExecutor>")[0].strip()
                arg_dict = json.loads(arg_dict_str)
                
                # If the extraction failed, do not execute the tool
                if "error" in arg_dict["content"]:
                    yield AgentResponse(
                        content=arg_dict_str,
                        status=AGENT_STATUS.GENERATING
                    )

                else:
                    ###########################################################
                    #                    Execute the tool                     #
                    ###########################################################
                    self.tool_name = arg_dict["content"]["tool_name"]
                    self.tool_arg = arg_dict["content"]["tool_arg"]
                    
                    
                    # User may change the tool call
                    yield AgentResponse(
                        content=json.dumps(arg_dict, indent=4),
                        status=AGENT_STATUS.TOOL_CALLING,
                        tool_arg={
                            "name": self.tool_name,
                            "args": self.tool_arg,
                        }
                    )

                    # Update the tool call when the user changes it
                    
                    if arg_dict["content"]["tool_name"] != self.tool_name or arg_dict["content"]["tool_arg"] != self.tool_arg:
                        arg_dict["content"]["tool_name"] = self.tool_name
                        arg_dict["content"]["tool_arg"] = self.tool_arg
                        arg_dict["content"]["analysis"] = "The user has changed the tool call. Use this tool instead to finish the plan."
                    
                    else:
                        for obs in self.tool_manager.call(self.tool_name, self.tool_arg):
                            # Only use the last 100 lines of the log
                            short_obs = "\n".join(obs.split("\n")[-100:])
                            arg_dict["content"]["running_log"] = short_obs
                            yield AgentResponse(
                                content=json.dumps(arg_dict, indent=4),
                                status=AGENT_STATUS.GENERATING,
                            )
            
                        # Check if the tool execution was successful
                        results = self.tool_manager.get_result(self.tool_name)
                        status = "error" if "error" in results else "success"
                        arg_dict["content"]["results"] = dict(results)
                        arg_dict["content"]["status"] = status
            
                        yield AgentResponse(
                            content=json.dumps(arg_dict, indent=4),
                            status=AGENT_STATUS.GENERATING,
                        )
        except Exception as e:
            # raise e
            response = {
                "sender": "tool_executor",
                "content": {
                    "error": str(e)
                }
            }
            yield AgentResponse(
                content=json.dumps(response, indent=4),
                status=AGENT_STATUS.ERROR
            )


